#!groovy

node {

    properties([disableConcurrentBuilds()])

    String branchName = ""
    String buildLabel = ""
    String buildVersion = ""
    boolean buildImages = false
    String targetEnv = ""
    String deploymentType = ""
    boolean clearImages = true

    try {

        // is manual build
        branchName = params.BRANCH?.trim()?.replaceFirst("origin/", "").toLowerCase()
        buildLabel = params.BUILD_LABEL?.trim()
        buildVersion = params.BUILD_VERSION?.trim()
        buildImages = params.BUILD_IMAGES
        queueDeploy = params.QUEUE_DEPLOY
        targetEnv = params.TARGET_ENV?.trim()
        deploymentType = params.TARGET_ROLE?.trim()
        clearImages = params.CLEAR_IMAGES
        

        if (!branchName) {
            error("No branch name was given!")
        }

            if (buildImages) {
                if (!buildLabel) {
                    error("Build label must be specified!: build label: '${buildLabel}'")
                }
                if (!buildVersion || buildVersion == "") {
                    echo("Build number not specified, using latest instead.")
                    buildVersion = "latest"
                }
                buildLabel = buildLabel + ':' + buildVersion
            }

        echo """Parameters:
    branchName: '${branchName}' 
    buildLabel: '${buildLabel}'
    buildVersion: '${buildVersion}'
    queueDeploy: '${queueDeploy}'
    buildImages: '${buildImages}'
    targetEnv: '${targetEnv}'
    clearImages: '${clearImages}'
    deploymentType: '${deploymentType}'
"""

        stage("Pull Source") {
        //trying to get the hash without checkout gets the hash set in previous build.
            def checkout = checkout scm
            env.COMMIT_HASH = checkout.GIT_COMMIT
            echo "Checkout done; Hash: '${env.COMMIT_HASH}'"
        }

        stage('Checkout frontend service') {
            dir('wsservice') {
                git 'https://KarenANolan@dev.azure.com/KarenANolan/EAD_CA1_WS/_git/EAD_CA1_WS'
            }
        }

        //This will use the content of the package.json file and install any needed dependencies into /node-modules folder
        stage("Install npm dependencies") {
            dir('wsservice') {
                configFileProvider([configFile(fileId: 'ae106d79-9e5d-4d2c-86f2-2f1827f8606f', replaceTokens: true, targetLocation: 'src/main/resources/config.properties', variable: 'databaseUrl')]) {
                    sh "sudo mvn -s clean package"
                }
            }
            echo "dependencies install completed"            
        }

        if (buildImages) {

            stage("Build Images") {
                dir('wsservice') {
                    echo "setting version: BUILD_LABEL='$env.BUILD_LABEL'; COMMIT_HASH='$env.COMMIT_HASH'"

                    sh "docker build -f Dockerfile-hollow -t ${buildLabel} ."

                    echo "Docker containers built with tag '${buildLabel}'"
                    sh "docker images ${buildLabel}"
                }
            }

            stage("Push Images") {
                sh "chmod +x ./push_images.sh"
                sh "./push_images.sh ${env.BUILD_LABEL} ${buildVersion}"
                echo "Docker images pushed to repository"
            }

            if (queueDeploy) {
                stage("Queue deploy") {

                    echo "Queueing Deploy job (${targetEnv}, ${buildLabel})."

                    acsDeploy(azureCredentialsId: '72555f61-7a9f-4145-8bb7-a163f107bccf',
                        resourceGroupName: 'mscdevops-aks-rg',
                        containerService: 'mscdevops-aks | AKS',
                        sshCredentialsId: '491fabd9-2952-4e79-9192-66b52c9dd389',
                        configFilePaths: '**/backend/*.yaml',
                        enableConfigSubstitution: true,

                    // Kubernetes
                    secretName: 'mscdevops',
                    secretNamespace: 'default',

                    // Docker Swarm
                    swarmRemoveContainersFirst: true,

                    // DC/OS Marathon
                    //dcosDockerCredentialsPath: '<dcos-credentials-path>',

                    containerRegistryCredentials: [
                        [credentialsId: 'dockerRegAccess', url: 'mcsdevopsentarch.azurecr.io'] ])
                }
            }
        }                   

    } catch (e) {
        throw e
    } finally {
        if (buildImages && clearImages) {
            stage("Clear Images") {
                echo "Removing images with tag '${buildLabel}'"
                sh "docker images ${buildLabel}"
                sh "docker rmi -f \$(docker images | grep '${env.BUILD_LABEL}' | awk '{print \$3}')"
            }
        }
        // Recursively delete the current directory from the workspace
        //deleteDir()
        echo "Build done."
    }
}
