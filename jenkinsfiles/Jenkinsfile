//1) clone services repo for dockerfile
//2) build docker - docker build . -t getintodevops-hellonode:1
//3) run locly docker run -it -p 8000:8000 getintodevops-hellonode:1
//4) test for response curl http://127.0.0.1:8000
//5) push to acr

#!groovy

node {

    properties([disableConcurrentBuilds()])

    // this disallows running multiple jobs for same branch at once

    def mainBranches = [:]
    mainBranches["master"] = [labelFormat: "jaz-{VERSION_TAG}"]

    String branchName = ""
    String buildLabel = ""
    boolean buildImages = false
    boolean queueDeploy = false
    String targetEnv = ""

    try {

        if (env.BRANCH_NAME?.trim()) {
            // if branch name comes from env, it is an automatic build
            branchName = env.BRANCH_NAME?.trim()
            if (mainBranches.containsKey(branchName)) {
                targetEnv = mainBranches[branchName].targetEnv
                buildImages = true
                queueDeploy = true
            }
        } else {
            // is manual build
            branchName = params.BRANCH?.trim()?.replaceFirst("origin/", "")
            buildLabel = params.BUILD_LABEL?.trim()
            buildImages = params.BUILD_IMAGES
            queueDeploy = params.QUEUE_DEPLOY
            targetEnv = params.TARGET_ENV?.trim()
        }

        if (!branchName) {
            error("No branch name was given!")
        }

        if (mainBranches.containsKey(branchName)) {
            if (buildImages) {
                if (!buildLabel) {
                    // label wasn't set manually
                    buildLabel = mainBranches[branchName].labelFormat?.replaceFirst("\\{VERSION_TAG\\}", "${env.BUILD_NUMBER}")
                }
                if (!buildLabel || buildLabel == "latest") {
                    error("Build label must be specified!: '${buildLabel}'")
                }
                env.BUILD_LABEL = buildLabel // env variable needed in setting the version
            }
        } else {
            buildImages = false
            queueDeploy = false
        }

        echo """Parameters:
    branchName: '${branchName}' 
    buildLabel: '${buildLabel}' 
    buildImages: '${buildImages}'
    queueDeploy: '${queueDeploy}'
    targetEnv: '${targetEnv}'
"""

        stage("Pull Source") {
//trying to get the hash without checkout gets the hash set in previous build.
            def checkout = checkout scm
            env.COMMIT_HASH = checkout.GIT_COMMIT
            echo "Checkout done; Hash: '${env.COMMIT_HASH}'"
        }

        if (buildImages) {

            stage("Build Images") {
                echo "setting version: BUILD_LABEL='$env.BUILD_LABEL'; COMMIT_HASH='$env.COMMIT_HASH'"

                sh "./gradlew setVersion"

                sh "./gradlew buildImage"
                echo "Containers built with tag '${buildLabel}'"
                sh "docker images | grep ${buildLabel}"
            }

            stage("Push Images") {
                sh "chmod +x ./push_images.sh"
                sh "./push_images.sh ${buildLabel}"
                echo "Docker images pushed to repository"
            }

            if (queueDeploy) {
                stage("Queue deploy") {
                    String deployType = "REDEPLOY"

                    echo "Queueing Deploy job (${targetEnv}, ${buildLabel}, ${deployType})."

                    build job: "Deploy",
                            parameters: [
                                    string(name: 'TARGET_ENV', value: "${targetEnv}"),
                                    string(name: 'BUILD_LABEL', value: "${buildLabel}"),
                                    string(name: 'DEPLOY_TYPE', value: "${deployType}")
                            ],
                            wait: false
                }
            }
        }

    } catch (e) {
        throw e
    } finally {
        if (buildImages) {
            stage("Clear Images") {
                echo "Removing images with tag '${buildLabel}'"
                sh "docker images | grep ${buildLabel}"
                sh "docker rmi -f \$(docker images | grep '${buildLabel}' | awk '{print \$3}')"
            }
        }

        echo "Build done."
    }
}
