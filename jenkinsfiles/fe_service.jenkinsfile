#!groovy

node {

    properties([disableConcurrentBuilds()])

    String branchName = ""
    String buildLabel = ""
    String buildVersion = ""
    boolean buildImages = false
    String targetEnv = ""
    String deploymentType = ""
    boolean clearImages = true

    try {

        // is manual build
        branchName = params.BRANCH?.trim()?.replaceFirst("origin/", "").toLowerCase() //master
        buildLabel = params.BUILD_LABEL?.trim()
        buildVersion = params.BUILD_VERSION?.trim()
        buildImages = params.BUILD_IMAGES
        queueDeploy = params.QUEUE_DEPLOY
        targetEnv = params.TARGET_ENV?.trim()
        deploymentType = params.DEPLOYMENT
        clearImages = params.CLEAR_IMAGES
        
        if (!branchName) {
            error("No branch name was given!")
        }

            if (buildImages) {
                if (!buildLabel) {
                    error("Build label must be specified!: build label: '${buildLabel}'")
                }
                if (!buildVersion) {
                    echo("Build number not specified, using latest instead.")
                    buildVersion = "latest"
                }
                buildLabel = buildLabel + ':' + buildVersion
                env.BUILD_LABEL = buildLabel // env variable needed in setting the version
            }

        echo """Parameters:
    branchName: '${branchName}' 
    buildLabel: '${buildLabel}'
    buildVersion: '${buildVersion}'
    queueDeploy: '${queueDeploy}'
    buildImages: '${buildImages}'
    targetEnv: '${targetEnv}'
    clearImages: '${clearImages}'
"""

        stage("Pull Source") {
        //trying to get the hash without checkout gets the hash set in previous build.
            def checkout = checkout scm
            env.COMMIT_HASH = checkout.GIT_COMMIT
            echo "Checkout done; Hash: '${env.COMMIT_HASH}'"
        }

        stage('Checkout frontend service') {
            dir('feservice') {
                git 'https://KarenANolan@dev.azure.com/KarenANolan/EAD_CA1_FE/_git/EAD_CA1_FE'
            }
        }

        //This will use the content of the package.json file and install any needed dependencies into /node-modules folder
        stage("Install npm dependencies") {
            dir('feservice') {
                sh "npm install"
            }
            echo "dependencies install completed"
        }

        if (buildImages) {

            stage("Build Images") {
                dir('feservice') {
                    echo "setting version: BUILD_LABEL='$env.BUILD_LABEL'; COMMIT_HASH='$env.COMMIT_HASH'"

                    sh "docker build -t ${buildLabel} ."

                    echo "Docker containers built with tag '${buildLabel}'"
                    sh "docker images | grep ${buildLabel}"
                }
            }

            stage("Push Images") {
                sh "chmod +x ./push_images.sh"
                echo "${buildLabel}"
                sh "./push_images.sh ${buildLabel}"
                echo "Docker images pushed to repository"
            }

            if (queueDeploy) {
                stage("Queue deploy") {

                    echo "Queueing Deploy job (${targetEnv}, ${buildLabel})."

                    withCredentials([azureServicePrincipal('72555f61-7a9f-4145-8bb7-a163f107bccf')]) {
                        // Login to azure
                        sh 'az login --service-principal -u $AZURE_CLIENT_ID -p $AZURE_CLIENT_SECRET -t $AZURE_TENANT_ID'
                        // Set subscription context
                        sh 'az account set -s $AZURE_SUBSCRIPTION_ID'
                        // Set aks context
                        sh 'az aks get-credentials --overwrite-existing --resource-group \"mscdevops-aks-rg\" --name \"mscdevops-aks\"'
                    }       

                    // Navigate to fe-service deployment directory
                    dir('aks/frontend'){
                        // Deploy the service
                        // envsubst '${DEPLOYMENT},DEPLOYMENT' <service.yaml
                        sh "DEPLOYMENT=${deploymentType} \\ envsubst '${DEPLOYMENT},DEPLOYMENT' <deploy.yaml | kubectl apply -f -"
                        // Deploy svc
                        sh "DEPLOYMENT=${deploymentType} \\ envsubst '${DEPLOYMENT},DEPLOYMENT' <service.yaml | kubectl apply -f -"
                    }
                }
            }
        }

    } catch (e) {
        throw e
    } finally {
        if (buildImages && clearImages) {
            stage("Clear Images") {
                echo "Removing images with tag '${buildLabel}'"
                sh "docker images | grep ${buildLabel}"
                sh "docker rmi -f \$(docker images | grep '${buildLabel}' | awk '{print \$3}')"
            }
        }
        // Recursively delete the current directory from the workspace
        deleteDir()
        echo "Build done."
    }
}
